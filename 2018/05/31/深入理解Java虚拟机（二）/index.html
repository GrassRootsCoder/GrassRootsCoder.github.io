<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.5" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.5">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.5" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.5',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="自动内存管理机制   以.java结尾的文件相信大家是每天都接触的，但是以.class结尾的文件却并不一定有了解，同时还有类的加载机制和加载器，理解虚拟机内部的一个子系统是需要通过这几个方面的。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java虚拟机（二）">
<meta property="og:url" content="http://yoursite.com/2018/05/31/深入理解Java虚拟机（二）/index.html">
<meta property="og:site_name" content="Dong Yan Blog">
<meta property="og:description" content="自动内存管理机制   以.java结尾的文件相信大家是每天都接触的，但是以.class结尾的文件却并不一定有了解，同时还有类的加载机制和加载器，理解虚拟机内部的一个子系统是需要通过这几个方面的。">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.0_JavaClassFile.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_ClassFileContent.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_FieldFileContent.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.1_ClassLifeCycle.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_BasicZeroValue.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.2_JavaClassLoader.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.3_TomcatClassLoader.png">
<meta property="og:updated_time" content="2018-08-04T16:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Java虚拟机（二）">
<meta name="twitter:description" content="自动内存管理机制   以.java结尾的文件相信大家是每天都接触的，但是以.class结尾的文件却并不一定有了解，同时还有类的加载机制和加载器，理解虚拟机内部的一个子系统是需要通过这几个方面的。">
<meta name="twitter:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.0_JavaClassFile.png">






  <link rel="canonical" href="http://yoursite.com/2018/05/31/深入理解Java虚拟机（二）/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>深入理解Java虚拟机（二） | Dong Yan Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dong Yan Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">I want something in my life.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/深入理解Java虚拟机（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dong Yan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%9C%88.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dong Yan Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Java虚拟机（二）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-31T00:00:00+08:00">2018-05-31</time>
            

            
            
              
                
              
            

            
              
              <span class="post-meta-divider">|</span>
              

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-08-05T00:00:00+08:00">2018-08-05</time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.0_JavaClassFile.png" alt="2.0_JavaClassFile.png"></p>
<a href="/2018/05/16/深入理解Java虚拟机（一）/" title="自动内存管理机制">自动内存管理机制</a> <br>

<p>以.java结尾的文件相信大家是每天都接触的，但是以.class结尾的文件却并不一定有了解，同时还有类的加载机制和加载器，理解虚拟机内部的一个子系统是需要通过这几个方面的。</p>
<a id="more"></a>



<h2 id="第三部分-虚拟机执行子系统"><a href="#第三部分-虚拟机执行子系统" class="headerlink" title="第三部分 虚拟机执行子系统"></a>第三部分 虚拟机执行子系统</h2><p>本部分从三个角度来描述虚拟机执行子系统，Class文件的结构、虚拟机的类加载机制以及字节码执行引擎。以.class结尾的文件是每个Java程序员都接触过的，类加载机制和字节码执行引擎就比较隐晦，藏在虚拟机的内部。</p>
<h3 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p>将.java结尾的文件编译成.class结尾的文件是Java编译器做的事情，Java虚拟机则是执行.class结尾的文件。.java文件使用自然语言编写的，.class文件则是以8位字节为基础的二进制流。</p>
<h4 id="6-2-无关性的基石"><a href="#6-2-无关性的基石" class="headerlink" title="6.2 无关性的基石"></a>6.2 无关性的基石</h4><p>不管使用哪种语言编写代码，只要有该语言对应的“编译器”就可以编译出.class文件，然后再由Java虚拟机执行。Java虚拟机并不关心.class文件是由何种语言编译而成的，因此虚拟机的无关性的基石就是.class文件，接下来就让我们来了解这个文件的结构。</p>
<h4 id="6-3-Class类文件的结构"><a href="#6-3-Class类文件的结构" class="headerlink" title="6.3 Class类文件的结构"></a>6.3 Class类文件的结构</h4><p><strong>注意：由于这部分内容比较枯燥，而且繁多，所以我只记录其中几个比较重要的内容，剩余内容同学们可以自己去翻看原书或者 Google 搜索。</strong></p>
<p>Class类文件格式呈现以下表格中的内容：</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_ClassFileContent.png" alt="ClassFileContent"></p>
<p>其中，u表示字节，u1、u2、u4分别表示1字节、2字节、4字节。</p>
<hr>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>由于常量池中的常量数量不一定，所以需要使用计数器来标记（如果有C语言基础的话，应该很快明白为什么要这样设计），并且计数器从1开始，不是Java语言中的0，因为设计者<strong>将0空出来作为特殊考虑（只有常量池这样，接口、字段、方法和属性还是从0开始）</strong>，用于表达“不引用任何一个常量池项目”含义。</p>
<p>常量池中主要存放：字面量（Literal）和符号引用（Symbolic References）。</p>
<p>其中，字面量与Java语言中的常量相似，String, final等变量。而符号引用则属于编译原理的概念：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符。</p>
<p>常量池中的每一项常量都是一张表，因此后面的内容需要翻看原书或者找其他资料。</p>
<hr>
<h5 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h5><p>在Java中声明一个字段需要包含什么信息呢？字段的作用域（public, protected, private）、字段的变量修饰符（static, final, volatile, transient）、字段的数据类型（基本数据类型和引用数据类型）以及字段的名称。以上内容中作用域和变量修饰符在字段表中的access_flags中，而数据类型和名称则需要找到常量池中的对应常量来描述。</p>
<p>字段表结构如下：</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_FieldFileContent.png" alt="FieldFileContent"></p>
<p>access_flags在之前已经解释过，name_index 和 descriptor_index 则表示字段的名称以及字段和方法的描述符。attribute_info需要自己去搜索相应资料。</p>
<hr>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>方法和字段的表结构一样，只是access_flags中内容不一样，因为方法没有volatile和transient修饰符，同时添加方法特有的synchronized、native、strictfp和abstract修饰符。</p>
<p>如果父类的方法没有被子类重写（Override），这方法表集合中就不会出现来自父类的方法信息。当重载（Overload）一个方法时，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名<strong>（在Java中，特征签名包含：方法名称、参数顺序以及参数类型；在字节码中，特征签名包含：Java的3种，外加返回值以及受查异常表）</strong>，而返回值没有被包含在方法的特征签名中，因此Java语言中不能使用返回值来重载一个方法。</p>
<hr>
<p>这部分内容还有一个属性（attribute_info）是比较重要的，由于过程比较枯燥，大家有兴趣的可以去看一下，没有兴趣的可以以后用着了再去看。</p>
<h3 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p>在第六章中简单描述了.class文件的内容，本章的主要内容是虚拟机如何执行这些.class文件。执行.class文件这一过程被称为<strong>类加载</strong>，虚拟机将描述类的数据从.class文件加载到内存中，并且对数据进行验证、准备、解析和初始化，最后得到一个可以使用的Java类型。</p>
<p>在Java中，类的加载、连接、初始化过程可以在程序运行期间完成，这样的特点为Java应用带来了很多特性，比如编写一个接口，在程序运行的时候再指定接口的实现类；可以自定义类加载器，从不同的地方加载类到应用中。JSP和<a href="https://web.archive.org/web/20130613171332/http://www.osgi.com.cn/" target="_blank" rel="noopener">OSGi技术</a>就是比较典型的应用场景。</p>
<h4 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h4><p>在虚拟机的类加载过程中，一共分为7个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三部分统称为<strong>连接</strong>。加载、验证、准备、初始化和卸载这5个阶段的执行顺序是确定的，而解析阶段是不确定的，因为Java存在运行时绑定（动态绑定），解析有可能会在初始化阶段后再执行。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.1_ClassLifeCycle.png" alt="2.1_ClassLifeCycle.png"></p>
<p>Java虚拟机规范中没有明确规定“加载”阶段何时开始，所以由虚拟机的具体实现来确定。但是“初始化”阶段就存在明确规定，有5种情况必须执行类的初始化（初始化之前的顺序执行的阶段也要执行）：</p>
<ol>
<li>new、getstatic、putstatic、invokestatic这4条字节码指令执行时，如果类没有进行初始化，则先进行初始化。</li>
<li>Java.lang.reflect包的方法对类进行反射时，如果类没有进行初始化，则先进行初始化。</li>
<li>当初始化一个类时，发现其父类还没有初始化，先初始化父类。</li>
<li>虚拟机启动时，用户需要指定一个执行主类（main()函数的类），先初始化这个类。</li>
<li>使用 JDK 1.7 的动态语言时，java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_puStatic和REF_invokeStatic的方法句柄，如果这个方法对应的类没有进行初始化，则先进行初始化。</li>
</ol>
<p>以上是Java规定的“有且仅有”的5种情况，这5种情况都是主动引用。除此之外，还存在3种被动引用（由于篇幅原因，感兴趣的同学可以自己去了解一下被动引用的情况）。</p>
<h4 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h4><p>在上述说的7个阶段中，使用和卸载阶段大家应该都熟悉了（卸载，类的信息被虚拟机移除），这里详细解析其他的5个阶段，加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）和初始化（Initialization）。</p>
<hr>
<h5 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h5><p>加载是类加载的第一个阶段，这个阶段中主要完成3件事情：</p>
<ol>
<li>通过一个类的全限定名称来获取定义该类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转化为虚拟机中方法区的运行时数据结构。</li>
<li>在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的访问入口。</li>
</ol>
<p>虚拟机规范中没有具体的规定这3件事情如何实现，因此灵活度非常大。对于第一件事情而言，并没有规定说从什么地方获取二进制字节流，因此在获取这件事情上可以大做文章：</p>
<ul>
<li>从ZIP（压缩包）中获取，后续转变为JAR、WAR、EAR格式。</li>
<li>从网络中获取，比如Applet（已经被淘汰的技术）。</li>
<li>运行时生成，比如常见的动态代理，使用java.lang.reflect.Proxy类生成指定接口的“*$Proxy”代理类的二进制字节流（在Debug模式中能够清晰看到代理类的信息）。</li>
<li>由其他文件生成，比如JSP技术。</li>
<li>从数据库中获取，比如中间件服务器（SAP Netweaver），这类型比较少见。</li>
</ul>
<p>在整个加载阶段中，非数组类的加载比较灵活，可以使用虚拟机提供的类加载器完成，也可以使用自定义的类加载器去控制字节流（重写loadClass()方法）。那么数组类就有所不同了，数组本身是由虚拟机直接创建的，而非类加载器。数组类和类加载器有一些关系，<strong>当数组除去所有维度后有一个元素类型（Element Type）</strong>，这个类型需要由类加载器加载，创建数组类的过程：</p>
<ul>
<li>当数组的<strong>组件类型（Componet Type，当数组除去一个维度后的类型）</strong>是引用类型，那么会按照本节中的加载过程去加载这个组件类型，然后数组将在加载该类型的类加载器的类名称空间上被标识。</li>
<li>当数组的组件类型不是引用类型（比如int[]），则虚拟机将该数组与引导类加载器关联。</li>
<li>数组类与组件类型的可见性一致（也就是访问权限），如果组件类型不是引用类型，则默认为public。</li>
</ul>
<p>当加载阶段完成后，字节流所包含的数据按照虚拟机所需的格式存放在方法区之中，方法区的存放格式由虚拟机自己实现，然后在内存中生成代表这个类的java.lang.Class对象，作为方法区的访问入口（也就是加载阶段的主要3件事情）。</p>
<hr>
<h5 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h5><p>这阶段的主要作用是验证.class文件中包含的信息是否会危害到虚拟机。在《Java虚拟机规范》中有大量篇幅来描述验证过程，虚拟机是如何约束和验证规范的，感兴趣的同学可以去翻看一下。目前验证阶段主要有4个检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<p><strong>1.文件格式验证</strong></p>
<p><strong>该动作需要检验.class文件是否能够被当前版本的虚拟机处理</strong>，主要包含以下验证点：</p>
<ul>
<li>是否以魔数 0xCAFEBABE 开头。</li>
<li>主、次版本号是否在当前虚拟机处理范围内。</li>
<li>常量池的常量中是否有不被支持的常量类型。</li>
</ul>
<p>以上只是一小部分验证点，想要看详细内容的需要去 Google 搜索一下。只有通过该验证的.class文件才能被虚拟机加载到内存中，其余3个检验动作都是在虚拟机的方法区中完成。</p>
<p><strong>2.元数据验证</strong></p>
<p><strong>该动作检验字节码描述的信息是否符合Java语言规范</strong>，主要包含以下验证点：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object，其他类都应该有父类）。</li>
<li>这个类的父类是否继承了不允许继承的类（如final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了父类或者接口中所有要求实现的方法（目前各种IDE工具都会帮忙在编码过程中检查）。</li>
</ul>
<p>还有一些验证点可以自己额外扩展，该动作主要保证不存在不符合Java规范的元数据信息。</p>
<p><strong>3.字节码验证</strong></p>
<p><strong>该动作比较复杂，主要对类的方法体进行校验分析，保证在程序运行时不会有对虚拟机的危害发生</strong>，主要包含以下验证点：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合，不会出现操作数栈是int类型，使用时按照long类型来使用。</li>
<li>保证跳转指令不会跳转到方法体意外的字节码指令上。</li>
<li>保证方法体中的类型转换时有效的。</li>
</ul>
<p>以上的验证点只是一部分，有可能会出现所有验证点都通过，但是还不能说一定是安全的（因为通过程序去校验程序逻辑是无法做到对决准确的）。因此，在 JDK 1.6 之后给方法体的Code属性的属性表中增加了一项名为“<strong>StackMapTable</strong>”的属性，这项属性描述了方法体中的所有基础块（Basic Block，按照控制流程拆分的代码块）开始时本地变量表和操作栈应用的状态。在字节码验证中，只需要验证“StackMapTable”中的内容即可。</p>
<p><strong>4.符号引用验证</strong></p>
<p><strong>最后的动作发生在虚拟机将符号引用转化为直接引用时，对类自身以外（常量池中的各种符号引用）的信息进行匹配，主要在解析阶段中发生</strong>，主要包含以下验证点：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名称是否能找到对应的类。</li>
<li>在对应的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段和方法的权限（private、protected、default和public）是否可被当前类访问。</li>
</ul>
<p>如果没有通过验证，会抛出java.lang.IncompatibleClassChangeError异常的子类，比如：NoSuchFieldError和NoSuchMethodError等。</p>
<p>对于整个应用程序而言，该阶段不是必须的，只要所加载的类符合虚拟机规范，这个阶段完全可以省略以节省性能消耗，可以给虚拟机添加-Xverify:none参数来关闭类的检验。</p>
<hr>
<h5 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h5><p>这个阶段是正式为类变量分配内存并且设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配（类变量指的是被static修饰的，其他是实例变量），而实例变量则在对象创建的时候在堆中进行分配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">100</span>; <span class="comment">// 类变量</span></span><br></pre></td></tr></table></figure>

<p> 在准备阶段后，number变量的初始值是0而非100，因为这个时候还没有执行任何Java方法，将number的值赋予100是putstatic指令被编译后，存放于类构造器&lt;clinit&gt;()方法之中，所以将number赋予100是在初始化阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量被final修饰了，那么在编译阶段会为number生成ConstantValue属性，<strong>在准备阶段虚拟机会根据ConstantValue属性给number赋值</strong>。</p>
<p>基本数据类型的零值（引用数据类型的零值是null）：</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_BasicZeroValue.png" alt="BasicZeroValue"></p>
<hr>
<h5 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h5><p>解析阶段是虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的阶段。</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，只要在使用之前能准确的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</li>
<li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。一般来说有直接引用了，那引用的目标一定存在内存中。</li>
</ul>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info这7种常量类型。其中，后面3种与JDK的动态语言相关，感觉兴趣的同学可以自己去了解一下。</p>
<p><strong>1.CONSTANT_Class_info（类或接口）</strong></p>
<p>假设执行当前代码的类是C，现在要解析一个从未解析过的符号引用S为一个类或者接口的直接引用D：</p>
<ol>
<li>如果D不是数组类型，那么虚拟机会将S的全限定名称传递给C的类加载器去加载D。</li>
<li>如果D是数组类型，并且元素类型为引用类型（S的描述符是[Ljava/lang/Integer），会按照1的步骤去加载这个元素类型，接着虚拟机生成一个代表此类数组维度和元素的数组对象。</li>
<li>如果以上步骤没有出错，那么D在虚拟机中已经是一个有效的类或者接口了，现在要判断当前的C是否有权限去访问D。</li>
</ol>
<p><strong>2.CONSTANT_Fieldref_info（字段）</strong></p>
<p>在解析字段之前（先解析字段表内的class_index项中索引的CONSTANT_Class_info），需要先解析类，如果类解析出现异常，那么字段解析也会失败。假设解析的字段属于类或者接口C：</p>
<ol>
<li>如果C本身包含的简单名称和字段描述符都与目标字段一致，那么直接返回这个字段的直接引用。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系递归从下往上寻找接口和父接口。如果接口本身包含的简单名称和字段描述符都与目标字段一致，那么直接返回这个字段的直接引用。</li>
<li>否则，如果在C继承了其他类（不是java.lang.Object），将会按照继承关系递归从下往上寻找父类。如果类本身包含的简单名称和字段描述符都与目标字段一致，那么直接返回这个字段的直接引用。</li>
<li>如果都没有找到，则查询失败。</li>
</ol>
<p>当找到了字段后，需要检查是否具备访问权限。</p>
<p><strong>3.CONSTANT_Methodref_info（类方法）</strong></p>
<p>解析方法之前与解析字段一样（从方法表内的class_info项中索引）。假设解析的方法属于类或者接口C：</p>
<ol>
<li>类方法和接口方法是分开定义的，如果在类方法的class_info中索引的是接口，则直接抛出异常。</li>
<li>如果C本身包含的简单名称和方法描述符都与目标方法一致，那么直接返回这个方法的直接引用。</li>
<li>否则，在C的父类中进行递归寻找，是否有包含简单名称和方法描述符都与目标方法一致，那么直接返回这个方法的直接引用。</li>
<li>否则，在C实现的接口中进行递归寻找，是否有包含简单名称和方法描述符都与目标方法一致，如果有则说明C是抽象类，直接抛出异常。</li>
<li>否则，寻找方法失败。</li>
</ol>
<p>当找到了方法后，需要检查是否具备访问权限。</p>
<p><strong>4.CONSTANT_InferfaceMethodref_info（接口方法）</strong></p>
<p>与类方法相似，也需要解析接口方法表内的class_info项中索引的CONSTANT_Class_info。</p>
<ol>
<li>如果在接口方法的class_info中索引的是类，则直接抛出异常（与类方法不同）。</li>
<li>如果C本身包含的简单名称和方法描述符都与目标方法一致，那么直接返回这个方法的直接引用。</li>
<li>否则，在C的父接口中进行递归寻找，是否有包含简单名称和方法描述符都与目标方法一致，那么直接返回这个方法的直接引用。</li>
<li>否则，寻找方法失败。</li>
</ol>
<p>由于接口中所有的方法默认权限是public，因此无需检查权限。</p>
<hr>
<h5 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h5><p>初始化是类加载的最后一个阶段，该阶段主要是执行Java代码。在准备阶段中，变量是赋予一次系统要求的初始值，而在初始化阶段中，则是根据程序员编写的代码进行赋值（执行类构造器&lt;clinit&gt;()方法）。</p>
<p>类构造器&lt;clinit&gt;()方法主要包含以下几个特点（仅适用于Java语言）：</p>
<ul>
<li>&lt;clinit&gt;()方法是由编译器自动收集类中的类变量（static修饰的变量）赋值操作和静态代码块（static{}）的集合，<strong>集合中的代码顺序是源文件的代码顺序，静态代码块中只能访问先定义在静态代码块前的类变量。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        System.out.printle(i); <span class="comment">// 无法在定义类变量前访问该变量，“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;clinit&gt;()方法与类的构造方法（&lt;init&gt;()方法）不同，无需显示调用父类构造器，<strong>虚拟机在执行子类的类构造器方法之前，一定会先执行父类的构造器方法。</strong>因此，最先执行类构造器方法的是java.lang.Object。</li>
<li>由于父类的&lt;clinit&gt;()方法先于子类执行，因此，父类的静态代码块优先于子类执行。</li>
<li>如果类中没有类变量的赋值操作以及静态代码块（接口没有静态代码块），则不会生成&lt;clinit&gt;()方法。</li>
<li>执行接口的&lt;clinit&gt;()方法无需先执行父接口的&lt;clinit&gt;()方法，除非父接口中存在对类变量的赋值操作。<strong>接口的实现类在初始化时也不会执行接口的&lt;clinit&gt;()方法。</strong></li>
<li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程中的安全执行，如果有多个线程同时执行一个类的&lt;clinit&gt;()方法，则只会有一个线程执行，其他线程进入阻塞状态，直到&lt;clinit&gt;()方法执行完毕。</li>
</ul>
<p>以上就是类加载的所有过程，对于Java程序员来说，接触最多的就是初始化阶段，其他阶段可能比较少见。</p>
<h4 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h4><p>还有记得前面在加载阶段说的“通过一个类的全限定名称来获取定义该类的二进制字节流”吗？完成这个操作的就是类加载器，它可以让程序自己决定如何去获取所需要的类，在类层次划分、热部署、OSGi等技术中大展身手。</p>
<hr>
<h5 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h5><p><strong>对于任何一个类来说，都需要由加载它的类加载器和该类本身一同确定在虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间。</strong>也就是说如果一个类被两个不同的类加载器给加载到虚拟机中，即使该类的.class文件相同，但是他们的类加载器不同，因此这两个类的比较结果就是“不相同”（比较的方法：equals()、isAssignableFrom()和isInstance()方法，以及instanceof关键字）。</p>
<hr>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>一般来说，类加载器共有三种系统提供的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存在&lt;JAVA_HOME&gt;\lib目录下的，或者由-Xbootclasspath参数指定的路径中，并且是能够被虚拟机识别的类库加载到虚拟机中。该加载器无法由Java程序直接调用，如果调用该加载器，需要在自定义类加载器的getClassLoader()方法中返回null。</li>
<li>扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，负责将&lt;JAVA_HOME&gt;\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载到虚拟机中。该类加载器可以直接调用。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sum.misc.Launcher$AppClassLoader实现，该类加载器是ClassLoader类中getSystemClassLoader()方法的返回值，因此也被叫做系统类加载器。负责加载用户类路径上（ClassPath）所指定的类库，该加载器可以直接调用，如果没有自定义类加载器，那么虚拟机默认使用该类加载器。</li>
</ul>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.2_JavaClassLoader.png" alt="2.2_JavaClassLoader.png"></p>
<p>上图就是类加载器的<strong>双亲委派模型（Parents Delegation Model）</strong>，除了在顶层的启动类加载器以外，其余类加载器都有自己的父类。类加载器之间不存在继承关系，是由<strong>组合关系</strong>来复用父加载器的代码。（JDK没有强制规定一定要使用该模型，因此会出现后续的“破坏双亲委派模型”）</p>
<p>双亲委派模型的流程是：假设一个类加载器收到了类加载的请求，首先是调用父加载器去加载，而不是自己本身去加载，每一个层次的类加载器都是如此，<strong>因此所有类加载器的请求最后都会传递到启动类加载器中，只有当父加载器反馈自己无法加载该类时（该类不在类加载器的寻找范围内），子加载器才会去加载。</strong></p>
<p>这样做的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。比如java.lang.Object类，该类存在放rt.jar中，无论哪个类加载器去加载它，最后都会调用启动类加载器去加载，因此保证了Object类在整个Java应用程序中的唯一性。否则，由不同的类加载器去加载，会出现多个Object类（在前面的章节中提到过类和类加载器的关系）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是java.lang.ClassLoader类中的loadClass()方法，该方法是保证双亲委派模型得以实现的基础，从方法的逻辑中可以看到，先检查该类是否被加载过，如果没有被加载过，那么则调用父加载器去加载，如果父加载器为空则调用默认的顶层类加载器（也就是启动类加载器）。如果父加载器失败（抛出ClassNotFoundException），则子加载器自己加载，调用findClass()方法。</p>
<hr>
<h5 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h5><p>该模型顾名思义，就是没有按照双亲委派模型的流程去执行。该模型离我们最近的实际应用就是热部署技术了，它主要由OSGi为基础（OSGi已经成为Java模块化的标准，感兴趣的同学可以去了解一下），底层的技术依赖就是类加载器。每一个程序模块（在OSGi中称为Bundle）都有一个自己的类加载器，当需要替换某一个模块时，直接模块连同类加载器一起替换，即实现了代码的替换。</p>
<p>在OSGi中，类加载器不再是树的结构，而是网结构（也可以叫图），流程如下：</p>
<ol>
<li>将以java.*开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，寻找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，寻找类是否再自己的Fragment Bundle中，如果再，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，寻找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类寻找失败。</li>
</ol>
<p>OSGi的类加载器很明显的不符合双亲委派模型，因此为了实现热部署也增加了很多复杂性，不过理解OSGi的实现，对于我们理解类加载器有着重要帮助。</p>
<h3 id="Tomcat-正统的类加载器架构"><a href="#Tomcat-正统的类加载器架构" class="headerlink" title="Tomcat 正统的类加载器架构"></a>Tomcat 正统的类加载器架构</h3><p>Tomcat作为一个Java Web容器，相信大部分人已经非常了解了，对于Tomcat的类加载器而言，它需要实现几个特定功能才能支持这个Web容器。</p>
<ul>
<li>部署在同一个容器下的两个不同的Web应用（在webapps目录下放置两个Java项目），所使用的Java类库应该相互隔离。（使用同一个类库的不同版本，比如Spring 3.X 和 Spring 4.X）</li>
<li>部署在同一个容器下的两个不同的Web应用（在webapps目录下放置两个Java项目），所使用的Java类库应该相互共享。（使用同一个类库的相同版本，比如Spring 5.X 和 Spring 5.X）</li>
<li>容器本身的安全问题不能受Web应用的影响。</li>
<li>支持JSP应用的容器，需要支持热部署功能（HotSwap）。</li>
</ul>
<p>为了支持以上的功能，只使用Java自带的类加载器显然是不可能的，因此Tomcat容器实现了很多自定义类加载器。在Tomcat 5.X的目录结构中（注意版本号），有3个目录（/common/*, /server/*, /shared/*）可以存放Java类库，再加上Web应用本身的/WEB-INF/*目录，一共4个目录，分别表示：</p>
<ul>
<li>common：存放的类库可被Tomcat和所有Web应用访问。</li>
<li>server：存放的类库可被Tomcat访问，所有Web应用无法访问。</li>
<li>shared：存放的类库可被所有Web应用访问，Tomcat无法访问。</li>
<li>WEB-INF：存放的类库仅仅被此Web应用访问，Tomcat和其他Web应用无法访问。</li>
</ul>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.3_TomcatClassLoader.png" alt="2.3_TomcatClassLoader.png"></p>
<p>上图就是Tomcat的类加载器架构图，可以看出Common、Catalina、Shared和WebApp类加载器架构，符合Tomcat容器的特征功能（Common可以被Tomcat和Web应用访问，Catalina只能被Tomcat访问，Shared只能被所有Web应用访问，WebApp只能被此Web应用访问）。最后的Jsp类加载器，一个JSP页面需要对应一个JSP类加载器。</p>
<p>前面我们提到了Tomcat 5.X以前的版本，当Tomcat版本是6.X之后的，将/common、/server和/shared目录统一合并成了lib目录。只有在conf/catalina.properties文件中指定了server.loader和shared.loader后，Tomcat才会使用CatalinaClassLoader和SharedClassLoader，默认情况下使用CommonClassLoader（一般情况下，使用该类加载器就足够）。</p>
<p>在<a href="https://archive.apache.org/dist/tomcat/" target="_blank" rel="noopener">这里</a>可以下载到所有版本的Tomcat。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/16/深入理解Java虚拟机（一）/" rel="next" title="深入理解Java虚拟机（一）">
                <i class="fa fa-chevron-left"></i> 深入理解Java虚拟机（一）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/21/月亮与六便士/" rel="prev" title="《月亮与六便士》">
                《月亮与六便士》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%9C%88.jpeg"
                alt="Dong Yan" />
            
              <p class="site-author-name" itemprop="name">Dong Yan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="mailto:cave19941023@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第三部分-虚拟机执行子系统"><span class="nav-text">第三部分 虚拟机执行子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第六章-类文件结构"><span class="nav-text">第六章 类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-概述"><span class="nav-text">6.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-无关性的基石"><span class="nav-text">6.2 无关性的基石</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-Class类文件的结构"><span class="nav-text">6.3 Class类文件的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常量池"><span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字段"><span class="nav-text">字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法"><span class="nav-text">方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第七章-虚拟机类加载机制"><span class="nav-text">第七章 虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-概述"><span class="nav-text">7.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-类加载的时机"><span class="nav-text">7.2 类加载的时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-类加载的过程"><span class="nav-text">7.3 类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#加载（Loading）"><span class="nav-text">加载（Loading）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#验证（Verification）"><span class="nav-text">验证（Verification）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#准备（Preparation）"><span class="nav-text">准备（Preparation）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解析（Resolution）"><span class="nav-text">解析（Resolution）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化（Initialization）"><span class="nav-text">初始化（Initialization）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-类加载器"><span class="nav-text">7.4 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类与类加载器"><span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双亲委派模型"><span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#破坏双亲委派模型"><span class="nav-text">破坏双亲委派模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat-正统的类加载器架构"><span class="nav-text">Tomcat 正统的类加载器架构</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dong Yan</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.5</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.5"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.5"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.5"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.5"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.5"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
