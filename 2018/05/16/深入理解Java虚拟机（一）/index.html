<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.5" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.5">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.5" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.5',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="早在刚学Java的时候就想理解JVM，不过当时本身基础还比较薄弱，同时也急于实践而非理论，因此JVM的学习计划就一直放缓。现在看完《计算机组成与设计》后，打下理解JVM的一些基础知识，加上在IT行业也待了一段时间，《深入理解Java虚拟机》这本书也不像当初那样令人害怕，甚至是更加吸引人，那种想要看底层实现和理论的心情被慢慢的激发出来，接下来让我们迫不及待地开始学习JVM吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java虚拟机（一）">
<meta property="og:url" content="http://yoursite.com/2018/05/16/深入理解Java虚拟机（一）/index.html">
<meta property="og:site_name" content="Dong Yan Blog">
<meta property="og:description" content="早在刚学Java的时候就想理解JVM，不过当时本身基础还比较薄弱，同时也急于实践而非理论，因此JVM的学习计划就一直放缓。现在看完《计算机组成与设计》后，打下理解JVM的一些基础知识，加上在IT行业也待了一段时间，《深入理解Java虚拟机》这本书也不像当初那样令人害怕，甚至是更加吸引人，那种想要看底层实现和理论的心情被慢慢的激发出来，接下来让我们迫不及待地开始学习JVM吧。">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.0_JavaVirtualMachineMonitor.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.1_JavaArchitecture.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.2_JavaMemoryModel.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_ObjectMemonery.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.7_GCRoots.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.3_Mark-Sweep.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.4_Copying.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.5_Mark-Compact.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.6_HotSpotGarbageCollection.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.8_GarbageCollector.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.9_SerialCollectorInYoung.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.10_ParNewCollectorInYoung.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.11_SerialOldCollectorInTenured.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.12_ParallelOldCollectorInTenured.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.13_CMSCollectorInTenured.png">
<meta property="og:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.14_G1Collector.png">
<meta property="og:updated_time" content="2018-06-19T16:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Java虚拟机（一）">
<meta name="twitter:description" content="早在刚学Java的时候就想理解JVM，不过当时本身基础还比较薄弱，同时也急于实践而非理论，因此JVM的学习计划就一直放缓。现在看完《计算机组成与设计》后，打下理解JVM的一些基础知识，加上在IT行业也待了一段时间，《深入理解Java虚拟机》这本书也不像当初那样令人害怕，甚至是更加吸引人，那种想要看底层实现和理论的心情被慢慢的激发出来，接下来让我们迫不及待地开始学习JVM吧。">
<meta name="twitter:image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.0_JavaVirtualMachineMonitor.png">






  <link rel="canonical" href="http://yoursite.com/2018/05/16/深入理解Java虚拟机（一）/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>深入理解Java虚拟机（一） | Dong Yan Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dong Yan Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">I want something in my life.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/16/深入理解Java虚拟机（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dong Yan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%9C%88.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dong Yan Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Java虚拟机（一）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-16T00:00:00+08:00">2018-05-16</time>
            

            
            
              
                
              
            

            
              
              <span class="post-meta-divider">|</span>
              

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-06-20T00:00:00+08:00">2018-06-20</time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.0_JavaVirtualMachineMonitor.png" alt="1.0_JavaVirtualMachineMonitor.png"></p>
<p>早在刚学Java的时候就想理解JVM，不过当时本身基础还比较薄弱，同时也急于实践而非理论，因此JVM的学习计划就一直放缓。现在看完《计算机组成与设计》后，打下理解JVM的一些基础知识，加上在IT行业也待了一段时间，《深入理解Java虚拟机》这本书也不像当初那样令人害怕，甚至是更加吸引人，那种想要看底层实现和理论的心情被慢慢的激发出来，接下来让我们迫不及待地开始学习JVM吧。</p>
<a id="more"></a>

<p>&lt;深入理解Java虚拟机&gt;这一系列的博客是个人的读书笔记，其中的内容不像原书那样俱全，所以想了解所有内容的同学，还是得自己去看原书。当你在看原书感到困惑时，希望本系列博客能够帮助你解决困惑，作为你读书学习之路上的伙伴。</p>
<a href="/2018/05/31/深入理解Java虚拟机（二）/" title="虚拟机执行子系统">虚拟机执行子系统</a> <br>



<h2 id="第一部分-走近Java"><a href="#第一部分-走近Java" class="headerlink" title="第一部分 走近Java"></a>第一部分 走近Java</h2><p><strong>这部分内容主要讲述Java语言和虚拟机的发展史，以及对于Java未来的展望，最后讲解如何获取JDK源码。</strong>因为书籍出版较早，使用的JDK版本还是1.7，JDK在2018年已经发行到JavaSE 10，所以这部分内容需要同学们自己与时俱进，去Oracle官方看看最近JDK几个版本的描述。</p>
<h3 id="第一章-走近Java"><a href="#第一章-走近Java" class="headerlink" title="第一章 走近Java"></a>第一章 走近Java</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>咱们先了解一下<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">编程语言</a>，再来看看<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java语言</a>。</p>
<p>各位同学也都不是编程小白，所以这部分内容去看看维基百科的内容就容易理解了（JavaSE 9发布后过了6个月后，JavaSE 10就紧跟发布，Oracle啥时候这么勤快）。</p>
<h4 id="1-2-Java技术体系"><a href="#1-2-Java技术体系" class="headerlink" title="1.2 Java技术体系"></a>1.2 Java技术体系</h4><p>JDK - JRE - JavaSE API</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.1_JavaArchitecture.png" alt="1.1_JavaArchitecture.png"></p>
<h4 id="1-3-Java发展史"><a href="#1-3-Java发展史" class="headerlink" title="1.3 Java发展史"></a>1.3 Java发展史</h4><p>可以去看看维基百科的<a href="https://zh.wikipedia.org/wiki/Java%E7%89%88%E6%9C%AC%E6%AD%B7%E5%8F%B2" target="_blank" rel="noopener">Java版本历史</a>，想要了解JavaSE 9 和 10的同学，可以自己去网络上搜索一下。</p>
<h4 id="1-4-Java虚拟机发展史"><a href="#1-4-Java虚拟机发展史" class="headerlink" title="1.4 Java虚拟机发展史"></a>1.4 Java虚拟机发展史</h4><p>这部分有很多内容，原书上已经有了很详细的讲解，如果感兴趣自己扩展。（<a href="https://www.zhihu.com/question/29265430" target="_blank" rel="noopener">知乎</a>，<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines" target="_blank" rel="noopener">维基百科</a>）</p>
<p>目前使用率最多的是<a href="https://en.wikipedia.org/wiki/HotSpot" target="_blank" rel="noopener">HotSpot虚拟机</a>。</p>
<h4 id="1-5-展望Java技术的未来"><a href="#1-5-展望Java技术的未来" class="headerlink" title="1.5 展望Java技术的未来"></a>1.5 展望Java技术的未来</h4><p>这本书写的时候只有JavaSE 7，JavaSE 8，9，10的新特性就是Java技术的未来实现。</p>
<p>JavaSE 8 特性（<a href="http://www.oracle.com/technetwork/cn/java/javase/8-whats-new-2157071-zhs.html" target="_blank" rel="noopener">Oracle官方文档</a>），JavaSE 9 特性（<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6" target="_blank" rel="noopener">Oracle官方文档</a>），</p>
<p>如果内存大于4GB，那么多数情况下都会使用64位虚拟机（也可以使用32位虚拟机搭建集群的方式）。随着硬件的发展（摩尔定律），今后肯定是64位虚拟机占主导地位。</p>
<h4 id="1-6-实战：自己编译JDK"><a href="#1-6-实战：自己编译JDK" class="headerlink" title="1.6 实战：自己编译JDK"></a>1.6 实战：自己编译JDK</h4><p>为了编译JDK，首先要弄清楚 <a href="https://en.wikipedia.org/wiki/OpenJDK" target="_blank" rel="noopener">OpenJDK</a> 和 OracleJDK 的关系（<a href="https://www.zhihu.com/question/19646618" target="_blank" rel="noopener">知乎</a>）。</p>
<p>OpenJDK<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">下载链接</a>。</p>
<p>～</p>
<h2 id="第二部分-自动内存管理机制"><a href="#第二部分-自动内存管理机制" class="headerlink" title="第二部分 自动内存管理机制"></a>第二部分 自动内存管理机制</h2><p><strong>这部分内容讲解Java虚拟机内存区域划分、垃圾收集器和内存分配策略，介绍了虚拟机性能监控工具以及一些调优实战案例。</strong>对于普通的程序员来说，理解虚拟机的内存区域、分配和垃圾收集器即可，性能优化还是有些距离的，我们可以时刻准备着调优的知识，然后耐心等待调优的机会。</p>
<blockquote>
<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。（引用原书）</p>
</blockquote>
<h3 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>本章节从概念上讲解了Java虚拟机内存的各个区域，它们的作用、服务对象以及其中可能产生的问题。</p>
<h4 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h4><p>在Java虚拟机中，有些区域随着虚拟机启动而加载，有些区域随着用户线程启动而加载，用户线程结束而销毁。根据<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">《The Java Virtual Machine Specification (Java SE 8 Edition)》</a>（有对应的中文版）的规定，因此Java虚拟机分为以下几个区域。<strong>（这张图需要重新做一下，在Java SE 8中运行时常量池在方法区中）</strong></p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.2_JavaMemoryModel.png" alt="1.2_JavaMemoryModel.png"></p>
<h5 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h5><p>Java虚拟机支持多线程执行，为了让多个线程同时执行并且不相互影响（在多核微处理器中，一个核在任意时刻只能执行一条线程，因此处理器会在多个线程之间切换，来达到多个线程同时执行），每个Java虚拟机线程都有一个自己的PC，用来记录下一条需要执行的指令。</p>
<p>如果线程执行的方法是Java方法，那么PC包含的正是当前执行的Java虚拟机指令的地址。如果是Native方法，PC的值为空（也可以叫未定义，Undefined）。</p>
<p><strong>该区域是Java虚拟机规范中没有规定任何OufOfMemoryError情况的区域。</strong></p>
<hr>
<h5 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h5><p>Java虚拟机栈与PC的生命周期相同。该区域是Java方法执行的内存模型：每个方法执行时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接和方法出口等信息。一个方法从调用到执行结束的过程，相当于一个栈帧在Java虚拟机栈中的入栈和出栈。</p>
<p>局部变量表存放了在编译期可知的各种基本数据类型（Java的8种基本数据类型）、对象引用（reference类型）和returnAddress类型（指向一条Java虚拟机指令的地址）。局部变量表的内存空间在编译期完成分配，当调用方法时，这个方法需要在栈帧中分配多少大小的局部变量表内存是完全确定的。</p>
<p><strong>该区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，会抛出OutOfMemoryError。</strong></p>
<hr>
<h5 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h5><p>本地方法栈和Java虚拟机栈的作用相似，它们的区别在于本地方法栈为虚拟机使用Native方法服务（<a href="https://zh.wikipedia.org/wiki/Java%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">维基百科</a>，<a href="https://www.quora.com/What-is-the-native-method-in-Java" target="_blank" rel="noopener">Quora</a>），Java虚拟机栈为虚拟机使用Java方法服务。在Sun HotSpot虚拟机中，将本地方法栈和Java虚拟机栈合并。<strong>与Java虚拟机栈一样，也会抛出StackOverflowError和OutOfMemoryError。</strong></p>
<hr>
<h5 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h5><p>在多数情况下，堆是Java虚拟机所管理的内存中最大的一块，同时也是所有线程共享的区域，在虚拟机启动时创建。堆主要存放所有类的实例和数组，不过随着JIT编译器（<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF" target="_blank" rel="noopener">Just In Time</a>，即时编译）的发展以及逃逸技术的逐渐成熟，所有实例并不一定分配在堆上。</p>
<p>从内存回收的角度看堆，可以分为：新生代和老年代。进一步划分为：Eden, From Survivor, To Survivor（有一些垃圾回收算法会这样划分堆区域）。从内存分配的角度看堆，每一个线程有自己的分配缓存区（Thread Local Allocation Buffer，TLAB），多个线程共享整个堆区域。无论怎么看待堆区域，最终的目的是更好的回收或者更快的分配内存。</p>
<p>堆区域是在物理上不连续，但是逻辑上必须连续的内存空间。<strong>该区域规定了如果堆区域的现有内存无法分配新的实例时，同时堆区域也无法继续扩展，会抛出OutOfMemoryError。</strong></p>
<hr>
<h5 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h5><p>方法区与堆一样被所有线程共享，主要存放被虚拟机加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据。在HotSpot虚拟机中，又将方法区成为永久代（Permanent Generation），目的是让垃圾收集器管理这部分内存和堆区域一样，省去编写专门回收方法区的收集器代码（因为这样划分是比较糟糕的，最后又进行了修改，<a href="https://www.zhihu.com/question/39990490" target="_blank" rel="noopener">知乎</a>，<a href="https://mp.weixin.qq.com/s/u5Aiuyo5lx_uNxPydZ7qoA" target="_blank" rel="noopener">InfoQ</a>）。</p>
<p>方法区在逻辑上属于堆的一部分，也存在着垃圾收集器，不过该区域的回收效果难以令人满意。方法区的回收目标主要是常量池的回收和类型的卸载，这些数据进入方法区后，回收条件相当苛刻。</p>
<p><strong>该区域规定了如果方法区的内存无法满足分配请求，会抛出OutOfMemoryError。</strong></p>
<hr>
<h5 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h5><p>运行时常量池是方法区的一部分，主要用于存放Class文件中的常量池（Constant Pool，这部分内容在6.3中）信息。当类或者接口被虚拟机加载后，这部分内容进入到方法区中的运行时常量池中（类的加载流程）。</p>
<p><strong>由于该区域是方法区的一部分，也会抛出OutOfMemoryError。</strong></p>
<hr>
<h5 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h5><p>这部分内容没有出现在Java虚拟机规范中，在原书中涉及到这区域。</p>
<p>JDK中的<a href="https://zh.wikipedia.org/wiki/Java_NIO" target="_blank" rel="noopener">NIO</a>类，引入了基于通道（Channel）与缓冲区（Buffer）的I/O方式，会使用Native函数库直接分配堆外内存，然后通过一个在堆内存中的DirectByteBuffer对象进行操作。这样的方法避免了Java堆和Native堆之间的复制数据，因此可以提高性能。</p>
<p>直接内存不会受到堆区域大小的限制，但是会受到计算机内存的限制。因此，堆和直接内存的总大小不能超过计算机的内存，否则会抛出OutOfMemoryError。</p>
<h4 id="2-3-HotSpot虚拟机对象探秘"><a href="#2-3-HotSpot虚拟机对象探秘" class="headerlink" title="2.3 HotSpot虚拟机对象探秘"></a>2.3 HotSpot虚拟机对象探秘</h4><p>在实际中使用最多的还是HotSpot虚拟机，因此本节主要探讨在HotSpot虚拟机的Java堆中对象的创建、内存布局和访问定位。对象指的是普通的Java对象，不包含数组和Class对象。</p>
<h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><p>当虚拟机执行到new指令时（创建对象的四种方式：new关键字，Class类或者Constructor类的newInstance方法，Clone方法，反序列化），首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个类的符号引用是否被加载、解析和初始化（类的加载流程在7中）。</p>
<p>当类加载完成后，为对象分配的堆内存大小已经完全确定，接着直接在Java堆中分配对象的内存。不同的垃圾收集器对应不同的分配方式，使用Serial、ParNew等基于Compact过程（Copying算法）的收集器时，采用指令碰撞方式；使用CMS这种基于Mark-Sweep算法的收集器时，采用空闲列表方式。（这两种方式的具体内容在3.3）</p>
<p>给对象分配堆内存的过程可能时并发状态下，为了解决冲突问题有两种方案：采用<a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2" target="_blank" rel="noopener">CAS</a>加上失败重试的方式保证更新操作的原子性；每一个线程有自己的分配缓冲区（TLAB）。</p>
<p>接着，虚拟机对对象进行必要的记录，将一些信息存放在对象头（Object Header）中。（这部分内容在对象的内存布局中）</p>
<p>最后，执行init方法，把对象根据代码进行初始化。</p>
<hr>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>在HotSpot虚拟机中，对象在内存中存储的布局分为三个部分：<a href="https://stackoverflow.com/questions/26357186/what-is-in-java-object-header" target="_blank" rel="noopener">对象头</a>（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>对象头包括两个部分：一个部分是“Mark Word”（<a href="https://stackoverflow.com/questions/26357186/what-is-in-java-object-header" target="_blank" rel="noopener">StackOverflow</a>，<a href="https://gist.github.com/arturmkrtchyan/43d6135e8a15798cc46c" target="_blank" rel="noopener">GitHub</a>），用于存储对象自身的运行时数据；另一个部分是类型指针，通过该指针确定对象是哪个类的实例，但是无法确定数组。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.3_ObjectMemonery.png" alt="ObjectMemonery"></p>
<p>实例数据存储的内容是对象中的各种类型的字段内容，无论是从父类中继承的，还是子类中定义的。这部分的存储顺序受到虚拟机的字段分配方式（FieldsAllocationStyle）参数和字段在Java代码中的顺序影响。HotSpot虚拟机的分配策略为：longs/doubles, ints, shorts/chars, bytes/booleans, oops（Ordinary Object Pointers）。宽度相同的字段分配到一起。</p>
<p>对齐填充这部分内容并不是一定存在的，它仅仅是起到占位符的作用。对象头部分的内容正好是8的倍数，因此不需要对齐。而实例数据部分的内容如果没有对齐时，才需要使用对齐填充来补全。</p>
<hr>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>在Java虚拟机规范中只规定了一个指向对象的引用，但是没有规定如何去定位、访问堆中的对象的具体位置。这部分由虚拟机自己实现，目前两个主流的访问方式为：句柄和直接指针。（<a href="https://blog.csdn.net/clover_lily/article/details/80095580" target="_blank" rel="noopener">参考链接</a>，由于画图使用时间比较多，以后有时间再回来补个图）</p>
<h4 id="2-4-实战：OutOfMemoryError"><a href="#2-4-实战：OutOfMemoryError" class="headerlink" title="2.4 实战：OutOfMemoryError"></a>2.4 实战：OutOfMemoryError</h4><p>该节通过代码和虚拟机参数，演示了Java虚拟机中可以发生异常的运行时数据区域是如何产生异常的（Program Counter Register除外）。</p>
<p>由于篇幅问题，实战内容另外写一篇博客。</p>
<h3 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>垃圾收集（Garbage Collection，GC）需要完成三件事情：哪些内存需要回收？（3.2）什么时候回收？（3.4）如何回收？（3.3）。</p>
<p>在第二章中讲述几个运行时数据区域，其中程序计数器、Java虚拟机栈和本地方法栈随着线程的启动而加载，线程的结束而销毁，因此不用考虑这三个区域的回收。方法调用时进栈，执行完毕时弹栈，栈区域的内容也不用回收。最后剩下堆和方法区，这些区域只有在程序运行的时候才知道会创建哪些对象，所以垃圾收集重点就在这些区域。</p>
<h4 id="3-2-对象已死吗"><a href="#3-2-对象已死吗" class="headerlink" title="3.2 对象已死吗"></a>3.2 对象已死吗</h4><p>垃圾收集需要知道哪些对象可以回收（存活），哪些对象不可以（死亡）。</p>
<h5 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h5><p>基本思路：给对象添加一个引用计数器，每当有一个引用指向对象时，计数器加1；当引用失效时，计数器减1。当一个对象的计数器为0时，说明这个对象不在被使用。</p>
<p>这个算法的优点在于可以很简单的实现，并且判断的效率高；缺点是无法解决对象循环引用问题。</p>
<h5 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h5><p>基本思路：有一系列的“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为引用链（Reference Chain），当一个对象到GC Roots没有任何一个引用链时（图论），说明该对象没有被使用。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.7_GCRoots.png" alt="1.7_GCRoots.png"></p>
<p>在Java中，GC Roots对象包括4种：虚拟机栈（栈帧中的本地变量表）中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；本地方法栈中JNI（Java Native Interface，Java本地接口）引用的对象。</p>
<hr>
<p>任何一个对象在某个时间中只有两种状态：有引用，无引用。如果一个对象是无引用的状态，直接判断为没有被使用对象进行回收，这样的判断是否有些武断。希望能更详细的描述一个对象：当内存空间足够时，保留在内存中；当内存空间进行垃圾收集之后还是不足够时，则清理掉这些对象。</p>
<p>因此，对引用（Reference）进行更详细的划分以此来描述对象，分为四种引用（强度依次减弱）：</p>
<ol>
<li>强引用（Strong Reference）：类似于new指令创建的对象。垃圾收集器不会回收这些对象。</li>
<li>软引用（Soft Reference）：描述有用而非必要的对象。在内存溢出之前进行回收，通常在进行第二次垃圾收集中回收。</li>
<li>弱引用（Weak Reference）：与软引用的描述相似，区别在于进行第一次垃圾收集中回收。</li>
<li>虚引用（Phantom Reference）：一个对象是否有虚引用，完全不会对其对象的生命周期有影响。</li>
</ol>
<hr>
<p>原书中提及了finalize()方法，能够拯救对象，不过这样的方式不推荐使用。</p>
<hr>
<p>对于方法区而言，也是存在回收的，只不过回收的性价比较低。因为在方法区中回收的目标是：废弃常量和无用的类。废弃常量的回收与堆区域中对象的回收很相似，当没有其他引用指向这些常量时，垃圾收集器就会清理这些常量（字符串、类、接口、方法和字段的符号引用）。</p>
<p>判断一个类是否为无用，这个条件就相当苛刻了：</p>
<ol>
<li>该类所有的实例都已经被回收，就是堆区域不存在任何该类的对象。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对象的java.lang.Class对象没有在任何地方被引用，在任何地方都无法通过反射调用该类的方法。</li>
</ol>
<p>满足了以上条件后，还要设置VM options才能够进行回收。在大量使用反射、动态代理、CGLib等ByteCode时，会加载大量的类到方法区中，因此在这些场景下的虚拟机需要具备类卸载的功能，保证方法区不会溢出。</p>
<h4 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h4><p>垃圾收集算法有很多种，本节主要理解基本算法的思想，对于其他算法可以自己扩展。现在网络上很多垃圾收集算法都会存有“永久代”，这个可以参考2.2节种方法区部分，现在应该叫元空间（Metespace）。因此，最新的垃圾收集算法原书上没有提及，想要理解更多的算法可以去看看网络上的资料。</p>
<h5 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记 - 清除算法（Mark - Sweep）"></a>标记 - 清除算法（Mark - Sweep）</h5><p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.3_Mark-Sweep.png" alt="1.3_Mark-Sweep.png"></p>
<p>这个算法分为两个阶段：首先标记出所有需要回收的对象，接着对这些标记的对象进行回收。其中标记对象的过程在3.2节中讲解过。标记 - 清除算法是最基本的算法，之后的算法都是在其基础上进行改良，完善算法的不足。</p>
<p>它的主要不足在于：效率问题，不管是标记还是清除效率都很低；另一个就是空间问题，当清除完对象之后，会余留很多细小的空间，之后有可能需要分配一个非常大的对象，这个时候没有一块完整连续的空间，这样不得不提前触发一次GC（Garbage Collection）。</p>
<h5 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h5><p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.4_Copying.png" alt="1.4_Copying.png"></p>
<p> 复制算法将内存分为两个部分，每次只使用其中的一个部分，当其中一部分内存使用完了，就回收该部分，同时把存活的对象移动到另外一部分去。这样的好处是可以整理内存，能余留出完整连续的空间，但是缺点也是非常明显，每次只能使用一半的内存。</p>
<p>由于新生代中98%的对象都是“朝生夕死”（这个数据不是明确数据），所以没有必要按照1:1的比例划分内存，应该划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当进行垃圾收集时，将Eden和Survivor中存活下来的对象移动到另外一块Survivor中。在HotSpot虚拟机中，Eden和Survivor的比例是8:1，每次只有10%的内存是不使用的（在说到“分代收集算法”时，会有HotSpot的内存布局图）。</p>
<p>不过，无法保证每次回收之后余留下来的对象不会超过10%的内存大小，当Survivor空间无法满足时，会依赖其他内存（老年代）进行分配担保。担保的结果就是将Survivor空间多余的对象直接放入老年代中。</p>
<h5 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记 - 整理算法（Mark - Compact）"></a>标记 - 整理算法（Mark - Compact）</h5><p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.5_Mark-Compact.png" alt="1.5_Mark-Compact.png"></p>
<p>复制算法的缺点在于每次都无法使用100%的内存空间，以及对象存活率较高时，需要进行较多的复制操作。当Survivor空间无法满足时，需要在老年代中存入对象。</p>
<p>根据老年代的对象特点，提出了标记 - 整理算法，与标记 - 清除算法相似，只是最后一步有所不同，整理算法是将对象回收后，把存活下来的对象都向一端移动。这样就能够余留出完整连续的空间出来。</p>
<h5 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h5><p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.6_HotSpotGarbageCollection.png" alt="1.6_HotSpotGarbageCollection.png"></p>
<p>HotSpot虚拟机目前就使用该算法进行垃圾收集。这种算法的主要思想是：根据对象存活周期的不同将内存分为几个区域，每个区域采用不同的收集算法。老年代的对象存活率高，同时没有额外的区域进行担保，所以采用Mark - Sweep 或者 Mark - Compact。新生代的对象大部分是“朝生夕死”（可以看到Eden Space的时间走势图，进行回收的时候几乎所有对象都被回收了），采用Copying能够降低每次移动对象的成本。</p>
<h4 id="3-4-HotSpot的算法实现"><a href="#3-4-HotSpot的算法实现" class="headerlink" title="3.4 HotSpot的算法实现"></a>3.4 HotSpot的算法实现</h4><p>在3.2节中讲述了对象存活判断算法（哪些内存需要回收？），3.3节中讲述了垃圾收集算法（如何回收？），现在就要了解HotSpot虚拟机如何执行算法（什么时候回收？），并且保证算法的高效运行。</p>
<h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>在可达性分析算法中从GC Roots节点找引用链为例子，可以作为GC Roots的节点主要是全局性的引用（常量或者静态属性）或者执行上下文（栈帧中的本地变量表），现在的应用中数据量都是非常庞大，如果要每个引用都检查一遍，那么效率肯定非常低。</p>
<p>同时，分析工作的执行时机必须是在一个能确保<strong>一致性</strong>（在整个分析过程中，整个系统像是停顿了一样，不可以出现对象的引用关系一直在变换的情况，否则分析工作的结果准确性不高）的快照中进行。为了让快照内的对象引用关系保持不变，在进行分析工作时Java的所有线程都处于停顿状态（Stop The World）。</p>
<p>在HotSpot的实现中，使用一组<strong>OopMap（枚举根节点）</strong>的数据结构来完成工作，在类加载完成的时候，HotSpot就把对象内中什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。当进行GC时，只要扫描OopMap就可以得知这些信息了。</p>
<h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>当使用了OopMap之后，如果对象的引用关系发生变化，那么OopMap内容变化的指令也就跟着增加，如果为每个指令生成OopMap，就需要大量的空间，同时GC的空间成本也随之上升。</p>
<p>因此，需要在“特定的位置”记录这些信息，这个位置被称为<strong>安全点（Safepoint）</strong>，相当于程序并非在所有地方都能停顿下来执行GC，而是在安全点的位置才开始执行GC。</p>
<p>如何设置安全点也是有讲究的，既不能多，也不能少，它需要在“是否具有让程序长时间执行的特征”下选定（长时间执行最明显的特征是指令序列复用，比如：方法调用、循环跳转、异常跳转等）。</p>
<p>当执行GC时，如何当所有线程都执行到最近的安全点上再停顿下来。有两种方案：抢先试中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。</p>
<p>抢先式是当GC发生时，所有线程全部中断，如果有线程不在安全点上时，则恢复该线程并且将代码执行到安全点上（目前的虚拟机都不采用该方案）。而主动式则是当GC发生时，不对线程进行直接操作，而是通过一个标志位进行操作，每个线程执行时轮询这个标志位，如果为真则直接中断挂起。标志位的设置和安全点重合。</p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>程序有时候会存在“不执行”（不执行意味着没有分配CPU时间，也就是线程处于Sleep或者Blocked状态）的状态，这个时候会产生无法响应GC发生时线程要执行到安全点的情况，同时GC也不太可能一直等待到CPU分配时间给线程。这个时候就需要引入一个<strong>安全区域（Safe Region）</strong>来解决问题。</p>
<p>安全区域指的是一段代码中，对象的引用关系不会再发生变化，也可以理解成扩展的安全点。只要到线程进入到安全区域之中，GC发生时，不管线程是否处于执行状态，都可以进入到中断状态。当线程要离开安全区域时，需要检查系统是否已经完成了GC或者枚举根节点，如果没有完成，则等待完成之后才能离开安全区域。</p>
<hr>
<p>该小节讲述了什么时候执行GC，至于虚拟机内部是如何执行的，就需要根据虚拟机选择的垃圾收集器来判断了，不同的收集器回收的方式不一样。</p>
<h4 id="3-5-垃圾收集器"><a href="#3-5-垃圾收集器" class="headerlink" title="3.5 垃圾收集器"></a>3.5 垃圾收集器</h4><p>垃圾收集器就是前面三小节内容的具体实现，Java虚拟机规范并没有详细的规则说明如何进行垃圾回收，因此不同的垃圾收集器的内部实现会完全不一样。</p>
<p>原书讨论的是JDK 1.7 Update 14之后的收集器，不过现在都是主流版本是1.8，因此这部分知识作为了解垃圾收集器，市面上也没有过多的博客介绍1.8之后的收集器。有关垃圾收集器的性能评测更加少，所以我们这部分停留在理论方面。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/" target="_blank" rel="noopener">Oracle官方网站介绍收集器</a></p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.8_GarbageCollector.png" alt="1.8_GarbageCollector.png"></p>
<p>上幅图一共表明了7种垃圾收集器，划分了两个区域（Young 新生，Tenured 终生），不同的收集器作用在不同的区域上，除了G1收集器可以同时作用在两个区域。收集器之间的连线表明它们可以相互合作。没有完美的收集器可以应用在任何场景，我们需要了解收集器的特性，明白在哪些场景使用哪些收集器可以达到最大的效果。</p>
<h5 id="Serial-Collector"><a href="#Serial-Collector" class="headerlink" title="Serial Collector"></a>Serial Collector</h5><p>Serial是年代最悠远的收集器，在JDK 1.3之前是Java虚拟机新生代中唯一的选择。它是一个单线程收集器，我喜欢称之为“串行”，只有一个CPU在执行，同时这个CPU执行的线程在运行垃圾收集算法，这样的话，程序就必须停止其他代码的运行，专心执行垃圾收集。Serial会带来一个后果，也就是我们前面所说的“Stop The World”。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.9_SerialCollectorInYoung.png" alt="1.9_SerialCollectorInYoung.png"></p>
<p>HotSpot虚拟机团队为了减少垃圾收集导致程序停顿的时间，从JDK 1.3开始就一直开发着新收集器，从Serial到Parallel，再到Concurrrent Mark Sweep，一直到Garbage First（G1），收集器性能变得越来越好，但是内部实现也越来越复杂，不管收集器变成什么样子，在执行垃圾收集时依然会存在停顿的时间。</p>
<p> Serial的优点：简单而高效（相对于其他单线程收集器），对于单CPU环境来说，不需要负担额外的线程开销成本，专心执行垃圾收集。用在Client应用上再好不过，因为Client端的内存不会很大，每次垃圾收集的时间大概在几十毫秒到一百多毫秒之间，只要发生GC的频率不是很大，这点停顿时间完全没问题。</p>
<h5 id="ParNew-Collector"><a href="#ParNew-Collector" class="headerlink" title="ParNew Collector"></a>ParNew Collector</h5><p>ParNew就是Serial的多线程版本，控制参数、收集算法、Stop The World（<a href="https://stackoverflow.com/questions/4406809/parnew-gc-will-stop-the-world" target="_blank" rel="noopener">StackOverflow</a>）、对象分配规则、回收策略等它们两个都是一样的。有一点不同，那就是ParNew一般运行在Server应用上。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.10_ParNewCollectorInYoung.png" alt="1.10_ParNewCollectorInYoung.png"></p>
<p>比较遗憾的是，在老年代中的CMS（之后会详细介绍）只能与Serial、ParNew配合，在JDK 1.4中出现的Parallel Scavenge无法与之配合。</p>
<p>这里会引入一些并发的概念，并发（Concurrent）和并行（Parallel）在计算机组成与设计（三）中有提到过。ParNew可以使用-XX:ParallelGCThreads参数来设置<strong>并行</strong>的线程数，线程数最好等同于计算机上的CPU个数。</p>
<h5 id="Parallel-Scavenge-Collector"><a href="#Parallel-Scavenge-Collector" class="headerlink" title="Parallel Scavenge Collector"></a>Parallel Scavenge Collector</h5><p>其实Parallel Scavenge与ParNew一样，在新生代中使用复制算法，也是<strong>多线程并行执行</strong>。只是它们两个的侧重点不同，其他收集器主要是为了减少垃圾收集的停顿时间，而Parallel Scavenge的目的是让程序达到一个可控制的<strong>吞吐量（Throughput）</strong>。</p>
<p>吞吐量 = 运行用户代码时间 / （运行运行用户代码时间 + 垃圾收集时间）</p>
<p>减少垃圾收集的停顿时间目的是为了良好的用户体验，而提高程序的吞吐量是为了高效利用CPU时间，主要用于尽快完成任务而不需要交互的后台程序。</p>
<p>Parallel Scavenge提供了-XX:MaxGCPauseMillis参数和-XX:GCTimeRatio参数来控制吞吐量，其中MaxGCPauseMillis（设置的值是大于0的毫秒值）参数是控制程序的内存回收时间，保证程序的垃圾收集时间不会超过该参数设置的值；GCTimeRatio（设置的是在0到100的整数）参数是控制垃圾收集时间占用总时间的比例，也就是吞吐量的倒数。</p>
<h5 id="Serial-Old-Collector"><a href="#Serial-Old-Collector" class="headerlink" title="Serial Old Collector"></a>Serial Old Collector</h5><p>Serial Old是Serial老年代版本，运行方式以及使用场景和Serial相似。在Server端的主要作用是：在JDK 1.5版本之前与Parallel Scavenge配合使用；作为CMS收集器的后背预案。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.11_SerialOldCollectorInTenured.png" alt="1.11_SerialOldCollectorInTenured.png"></p>
<h5 id="Parallel-Old-Collector"><a href="#Parallel-Old-Collector" class="headerlink" title="Parallel Old Collector"></a>Parallel Old Collector</h5><p>Parallel Old是Parallel Scavenge的老年代版本。该收集器是JDK1.6版本发布的，在以前的版本中如果新生代使用Parallel Scavenge，则老年代只能使用Serial Old，在一开始介绍收集器时说过CMS无法和Parallel Scavenge一起使用，因此以吞吐量为主的收集器在JDK1.6以前效果不是很好。</p>
<p>当Parallel Old发布以后，以吞吐量优先的收集器终于有了特定的使用场景，在注重吞吐量和CPU资源的场景下，可以优先考虑Parallel Scavenge加Parallel Old组合。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.12_ParallelOldCollectorInTenured.png" alt="1.12_ParallelOldCollectorInTenured.png"></p>
<h5 id="CMS-Collector"><a href="#CMS-Collector" class="headerlink" title="CMS Collector"></a>CMS Collector</h5><p>CMS（Concurrent Mark Sweep，并发标记清除）收集器是一种以获取最短回收停顿时间为目标的收集器。在互联网项目或者B/S架构为主的项目中，非常在意服务器的响应速度，希望程序停止执行的时间尽量减少，这样的场景非常适合CMS收集器。从CMS收集器的名字可以看出来，它是并发执行的，而且使用的是标记 - 清除算法，CMS进行GC主要分为四个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>初始标记和重新标记这两个步骤还是会发生Stop The World，其他两个步骤是并发执行。<strong>初始标记步骤</strong>仅仅只是标记一下GC Roots能直接关联到的对象；<strong>并发标记步骤</strong>是进行GC Roots Tracing的过程；<strong>重新标记步骤</strong>则是为了修正并发标记步骤中因用户程序继续运行而导致标记产生变化的一部分对象的标记；<strong>并发清除步骤</strong>是程序一边运行一边清除被标记的对象。</p>
<p>在这四个步骤中，耗时最多的是并发标记和并发清除步骤，不过这两个步骤是与用户程序一起并发执行的，因此程序停顿的时间不会很长。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.13_CMSCollectorInTenured.png" alt="1.13_CMSCollectorInTenured.png"></p>
<p> 不过CMS收集器也并不是完美的，它还存在几个比较明显的缺点：</p>
<ul>
<li><strong>CMS收集器对CPU资源非常敏感。</strong>如果服务器上的CPU个数是4个，则在进行并发标记和并发清除时会占用一条线程，这个时候CPU的吞吐量只有75%，这个吞吐量随着CPU个数的减少而减少。如果服务器只有2个CPU时，则在并发步骤中吞吐量下降到50%，这样的吞吐量不会让人满意。</li>
<li><strong>CMS收集器无法处理浮动垃圾（Floating Garbage），可能会出现”Concurrnet Mode Failure”而导致另一次Full GC的产生。</strong>因为CMS是并发标记的，所以在这个阶段中产生的对象无法在当前GC中被标记，到清除阶段时这些对象会留下来，等到下次GC再进行回收，这些对象就是“浮动垃圾”。由于CMS进行GC时用户程序还在继续执行，因此需要留一部分空间给程序分配对象，如果这部分空间无法满足用户程序的需求，则会触发“Concurrent Mode Failure”，这个时候虚拟机会启动备用方案，使用Serial Old进行老年代回收，性能方面会下降很多。</li>
<li><strong>CMS收集器使用Mark - Sweep算法。</strong>Mark - Sweep算法的缺点在之前的章节中已经提过，每次回收之后会余留小碎片的内存，导致无法分配内存占用很大的对象。</li>
</ul>
<h5 id="G1-Collector"><a href="#G1-Collector" class="headerlink" title="G1 Collector"></a>G1 Collector</h5><p>G1（Garbage First，<a href="https://en.wikipedia.org/wiki/Garbage-first_collector" target="_blank" rel="noopener">维基百科</a>）收集器从JDK1.6开始测试，一直到JDK1.7才达到足够成熟的商用程度。G1收集器的目的是替代CMS收集器，它主要有几个特点：（G1收集器虽然是当今收集器技术发展的最前沿成果，但是Google声明修改后的CMS比G1的效率高）</p>
<ul>
<li>并发与并行：利用多CPU、多核的硬件环境。缩短Stop The World的时间。</li>
<li>分代收集：采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象。</li>
<li>空间整合：使用Mark - Compact算法，不会产生大量小碎片的空间。</li>
<li>可预测的停顿：可以建立可预测的停顿时间模型，在垃圾收集的时间不超过N毫秒。</li>
</ul>
<p>G1收集器不像之前的收集器那样只作用在一个区域（新生代和老年代），它的Java堆内存布局与其他收集器存在很大的区别。它的堆内存被分为多个大小相同的独立区域（Region），虽然还保留新生代和老年代的概念，但是这个概念只存在于逻辑上，而不是物理内存上。</p>
<p>由于堆内存被分为多个独立区域，G1可以跟踪每个区域的堆价值（回收空间与回收时间的比例），在后台维护一个优先列表，在每次允许回收收集时间中，优先回收堆价值最大的区域。这也是G1收集器的命名由来。</p>
<p>当一个对象进入到内存中，不可能只被当前所在的区域引用，所有区域都可以引用该对象。那么在确认一个对象是否存活时，还是要扫描所有区域才能确保准确性。在G1收集器中，使用Remembered Set来避免扫描所有的区域。每一个区域都有一个对应的Remembered Set，当虚拟机发现用户程序对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同区域，如果是则通过CardTable把相关信息写入被引用对象的区域中的Remembered Set中。进行GC时，只要扫描Remembered Set即可，不用扫描所有的区域。</p>
<p>如果不计入维护Remembered Set的操作，G1收集器分为四个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<p><strong>初始标记步骤</strong>与CMS一样，同时修改了TAMS（Next Top at Mark Start）的值，让用户程序在之后的步骤中能正确的在区域中创建对象；<strong>并发标记步骤</strong>与CMS一样；<strong>最终标记步骤</strong>是为了修正并发标记步骤中的变动记录，将对象变化记录在Rememberes Set Logs中，在该步骤中将Logs的数据合并到Remembered Set中，可以暂停线程执行，也可以并发执行；<strong>筛选回收步骤</strong>会找到堆价值最大的区域进行回收，该步骤可以并发执行也可以暂停线程单独执行，由于只回收一部分区域，暂停用户线程回收的效率更好。</p>
<p><img src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.14_G1Collector.png" alt="1.14_G1Collector.png"></p>
<p>PS：看懂GC日志的部分在实战博客中。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/10/一个孤独漫步者的遐想/" rel="next" title="《一个孤独漫步者的遐想》">
                <i class="fa fa-chevron-left"></i> 《一个孤独漫步者的遐想》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/31/深入理解Java虚拟机（二）/" rel="prev" title="深入理解Java虚拟机（二）">
                深入理解Java虚拟机（二） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://dongyanblog.oss-cn-shenzhen.aliyuncs.com/%E6%9C%88.jpeg"
                alt="Dong Yan" />
            
              <p class="site-author-name" itemprop="name">Dong Yan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="mailto:cave19941023@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分-走近Java"><span class="nav-text">第一部分 走近Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章-走近Java"><span class="nav-text">第一章 走近Java</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-概述"><span class="nav-text">1.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Java技术体系"><span class="nav-text">1.2 Java技术体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-Java发展史"><span class="nav-text">1.3 Java发展史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-Java虚拟机发展史"><span class="nav-text">1.4 Java虚拟机发展史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-展望Java技术的未来"><span class="nav-text">1.5 展望Java技术的未来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-实战：自己编译JDK"><span class="nav-text">1.6 实战：自己编译JDK</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二部分-自动内存管理机制"><span class="nav-text">第二部分 自动内存管理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章-Java内存区域与内存溢出异常"><span class="nav-text">第二章 Java内存区域与内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-概述"><span class="nav-text">2.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-运行时数据区域"><span class="nav-text">2.2 运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#程序计数器（Program-Counter-Register）"><span class="nav-text">程序计数器（Program Counter Register）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）"><span class="nav-text">Java虚拟机栈（Java Virtual Machine Stacks）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#本地方法栈（Native-Method-Stacks）"><span class="nav-text">本地方法栈（Native Method Stacks）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆（Heap）"><span class="nav-text">堆（Heap）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法区（Method-Area）"><span class="nav-text">方法区（Method Area）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#运行时常量池（Runtime-Constant-Pool）"><span class="nav-text">运行时常量池（Runtime Constant Pool）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#直接内存（Direct-Memory）"><span class="nav-text">直接内存（Direct Memory）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-HotSpot虚拟机对象探秘"><span class="nav-text">2.3 HotSpot虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的创建"><span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的内存布局"><span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的访问定位"><span class="nav-text">对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-实战：OutOfMemoryError"><span class="nav-text">2.4 实战：OutOfMemoryError</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章-垃圾收集器与内存分配策略"><span class="nav-text">第三章 垃圾收集器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-概述"><span class="nav-text">3.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-对象已死吗"><span class="nav-text">3.2 对象已死吗</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引用计数算法（Reference-Counting）"><span class="nav-text">引用计数算法（Reference Counting）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可达性分析算法（Reachability-Analysis）"><span class="nav-text">可达性分析算法（Reachability Analysis）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-垃圾收集算法"><span class="nav-text">3.3 垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#标记-清除算法（Mark-Sweep）"><span class="nav-text">标记 - 清除算法（Mark - Sweep）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#复制算法（Copying）"><span class="nav-text">复制算法（Copying）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标记-整理算法（Mark-Compact）"><span class="nav-text">标记 - 整理算法（Mark - Compact）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分代收集算法（Generational-Collection）"><span class="nav-text">分代收集算法（Generational Collection）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-HotSpot的算法实现"><span class="nav-text">3.4 HotSpot的算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#枚举根节点"><span class="nav-text">枚举根节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全点"><span class="nav-text">安全点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全区域"><span class="nav-text">安全区域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-垃圾收集器"><span class="nav-text">3.5 垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-Collector"><span class="nav-text">Serial Collector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew-Collector"><span class="nav-text">ParNew Collector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scavenge-Collector"><span class="nav-text">Parallel Scavenge Collector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-Old-Collector"><span class="nav-text">Serial Old Collector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Old-Collector"><span class="nav-text">Parallel Old Collector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS-Collector"><span class="nav-text">CMS Collector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1-Collector"><span class="nav-text">G1 Collector</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dong Yan</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.5</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.5"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.5"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.5"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.5"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.5"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
